@report{Biere-FMV-TR-11-2,
  title = {{{AIGER}} 1.9 and Beyond},
  author = {Biere, Armin and Heljanko, Keijo and Wieringa, Siert},
  year = {July 2011, 2011},
  number = {11/2},
  institution = {{Institute for Formal Models and Verification, Johannes Kepler University}},
  location = {{Altenbergerstr. 69, 4040 Linz, Austria}},
}

@inproceedings{braytonABCAcademicIndustrialStrength2010,
  title = {{{ABC}}: {{An Academic Industrial-Strength Verification Tool}}},
  shorttitle = {{{ABC}}},
  booktitle = {Computer {{Aided Verification}}},
  author = {Brayton, Robert and Mishchenko, Alan},
  editor = {Touili, Tayssir and Cook, Byron and Jackson, Paul},
  date = {2010},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {24--40},
  publisher = {{Springer}},
  location = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-642-14295-6_5},
  abstract = {ABC is a public-domain system for logic synthesis and formal verification of binary logic circuits appearing in synchronous hardware designs. ABC combines scalable logic transformations based on And-Inverter Graphs (AIGs), with a variety of innovative algorithms. A focus on the synergy of sequential synthesis and sequential verification leads to improvements in both domains. This paper introduces ABC, motivates its development, and illustrates its use in formal verification.},
  isbn = {978-3-642-14295-6},
  langid = {english},
  keywords = {equivalence checking,integrated sequential verification flow,logic synthesis,Model checking,simulation},
}

@inproceedings{bradleySATBasedModelChecking2011,
  title = {{{SAT-Based Model Checking}} without {{Unrolling}}},
  booktitle = {Verification, {{Model Checking}}, and {{Abstract Interpretation}}},
  author = {Bradley, Aaron R.},
  editor = {Jhala, Ranjit and Schmidt, David},
  date = {2011},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {70--87},
  publisher = {{Springer}},
  location = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-642-18275-4_7},
  abstract = {A new form of SAT-based symbolic model checking is described. Instead of unrolling the transition relation, it incrementally generates clauses that are inductive relative to (and augment) stepwise approximate reachability information. In this way, the algorithm gradually refines the property, eventually producing either an inductive strengthening of the property or a counterexample trace. Our experimental studies show that induction is a powerful tool for generalizing the unreachability of given error states: it can refine away many states at once, and it is effective at focusing the proof search on aspects of the transition system relevant to the property. Furthermore, the incremental structure of the algorithm lends itself to a parallel implementation.},
  isbn = {978-3-642-18275-4},
  langid = {english},
  keywords = {Inductive Generalization,Model Check,Safety Property,Symbolic Model Check,Transition Relation},
}

@inproceedings{fazekasIncrementalInprocessingSAT2019,
  title = {Incremental {{Inprocessing}} in {{SAT Solving}}},
  booktitle = {Theory and {{Applications}} of {{Satisfiability Testing}} – {{SAT}} 2019},
  author = {Fazekas, Katalin and Biere, Armin and Scholl, Christoph},
  editor = {Janota, Mikoláš and Lynce, Inês},
  date = {2019},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {136--154},
  publisher = {{Springer International Publishing}},
  location = {{Cham}},
  doi = {10.1007/978-3-030-24258-9_9},
  abstract = {Incremental SAT is about solving a sequence of related SAT problems efficiently. It makes use of already learned information to avoid repeating redundant work. Also preprocessing and inprocessing are considered to be crucial. Our calculus uses the most general redundancy property and extends existing inprocessing rules to incremental SAT solving. It allows to automatically reverse earlier simplification steps, which are inconsistent with literals in new incrementally added clauses. Our approach to incremental SAT solving not only simplifies the use of inprocessing but also substantially improves solving time.},
  isbn = {978-3-030-24258-9},
  langid = {english},
}

@article{biereEnteringSATCompetition2020,
  title = {Entering the {{SAT Competition}} 2020},
  author = {Biere, Armin and Fleury, Mathias and Heisinger, Maximilian and Fazekas, Katalin},
  date = {2020},
  pages = {4},
  abstract = {This system description describes our new SAT solver KISSAT, how it differs from CADICAL, as well as changes made to CADICAL. We further present our new distributed cubeand-conquer solver PARACOOBA. Previous parallel SAT solvers PLINGELING and TREENGELING in essence remain unchanged.},
  langid = {english},
}

@inproceedings{fazekasIncrementalInprocessingSAT2019,
  title = {Incremental {{Inprocessing}} in {{SAT Solving}}},
  booktitle = {Theory and {{Applications}} of {{Satisfiability Testing}} – {{SAT}} 2019},
  author = {Fazekas, Katalin and Biere, Armin and Scholl, Christoph},
  editor = {Janota, Mikoláš and Lynce, Inês},
  date = {2019},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {136--154},
  publisher = {{Springer International Publishing}},
  location = {{Cham}},
  doi = {10.1007/978-3-030-24258-9_9},
  abstract = {Incremental SAT is about solving a sequence of related SAT problems efficiently. It makes use of already learned information to avoid repeating redundant work. Also preprocessing and inprocessing are considered to be crucial. Our calculus uses the most general redundancy property and extends existing inprocessing rules to incremental SAT solving. It allows to automatically reverse earlier simplification steps, which are inconsistent with literals in new incrementally added clauses. Our approach to incremental SAT solving not only simplifies the use of inprocessing but also substantially improves solving time.},
  isbn = {978-3-030-24258-9},
  langid = {english},
}

@article{chenNewSATEncoding2010,
  title = {A {{New SAT Encoding}} of the {{At-Most-One Constraint}}},
  author = {Chen, Jingchao},
  date = {2010},
  journaltitle = {Proc. Constraint Modelling and Reformulation},
  pages = {8},
  abstract = {In this paper, we study how to encode the at-most-one (AMO) constraint in conjunctive normal form (CNF). The AMO constraint means that at most one out of n propositional variables is allowed to be true.},
  langid = {english},
}
